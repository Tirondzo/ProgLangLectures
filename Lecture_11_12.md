### Лекция 11, 12 08.10.19
#### Числовые типы данных
Числовые типы данных — **целочисленные**:

1. *Беззнаковые?*

```C++
 i < c.size() // i - int, size() - uint
 // integer overflow
 checked {...}
 unchecked {...}
```
> С точки зрения вычислений знаковый тип главнее.
> С точки зрения кода битовое представление знаковых и беззнаковых типов неразличимы (первый бит может быть после интерпретирован по-разному).
> Компилируемость определяется врменем связывания (если короткое, то проще компилировать, иначе — интерпретировать).

2. *Представление (размерность)*
     * Динамическая типизация (интерпретируемость). JavaScript (нет знаковых и беззнаковых, есть один тип — number, из-за этого все вычисления неточные). Python (int; long — вычисления с произвольной длиной, в Python3 отказались от двух типов, остался int, который по факту long из Python2 — по сути ссылка на объект из динамической памяти, строка = числу).
     Ссылки можно присвоить одна другой и они будут ссылаться на один и тот же объект (это проверятся в Python операцией is), и через ссылку можно добраться до свойств объекта.
     * Статическая типизация (компилируемость) —  более производительны. Есть беззнаковые (кроме Java, там byte, short, int, long — все знаковые). C, C++, C#, Go (int8, int16, int32, int64 и byte, uin16, uint32, uint64; int, uint, uintptr), Swift (Int8, int16, Int32, Int64 и Uint8, Uint16, Uint32, Uint64; int, uint, uintptr). В основном объектно-референциальные языки. Проблема: что является родным размером int? Регистры общего назначения, если int будет меньше, то будет падение эффективности, не все возможности процессора будут использованы.

 > Разговор за процессоры 
 
|      |short|int|long|pointer|long long|
|------|-----|---|----|-------|---------|
|LP32  |2    |2  |4   |4      |-        |
|ILP32 |2    |4  |4   |4      |8        |
|ILP64*|2    |8  |8   |8      |?        |
|LP64  |2    |4  |8   |8      |8        |
|LLP64 |2    |4  |4   |8      |8        |
 
IA-32 (1987)
IA-64 (2001)
-> x86-64

**Вещественные числа**

Можно представлять с плавающей точой, а можно с фиксированной (как в раннних компьютерах: числа хранились в десятичном формате по цифрам, каждая занимала 4 бита. В Python есть тип Decimal, который хранится подобным образом).
mantissa * base ^ p 
1 \frac base <= mantissa < 1 

В Ada (последний ЯП с фиксированными типами): 

```Ada
type T is digits 8; // точность 8 знаков
type MESH is delta H range L..R; // в пределах от L до R с шагом H, статические константы
```

По стандарту IEEE-754 (1985): float, double, long long double.

1. *Стандартное представление*
    32 и 64 бита: 1 бит знак, мантисса (23 или 52 бита) и порядок — p' (8 или 11 бит). p' из всех 0 или 1 зарезервированы.
    p' = p + 2^(n-1) - 1
    p' = p + 127 (float)
    p' = p + 1023 (double)
    
2. *Underflow *(не хватает мантиссы), возникает понятие Nan. Nan всегда не равен другому числу d (даже если d=Nan). В операциях с другими числами даст Nan. Нужно обрабатывать случаи возникновения Nan.
   * Overflow* (не хватает порядка), возникает понятие +-inf. 1/(+-inf).


> — Как поймать 6 львов? 
— Поймать 10 и 4 выпустить.

#### Логический тип данных
Логические операции так или иначе есть во всех ЯП, но типа данных может и не быть
0 = false
\#0 => true => 1 (в VisualBasic -1)
and or not (xor — иногда, equal)
f(e1, e2, ..., eN): может вычисляться компилятором в любом порядке, например:
```C
f(i++, ++i) // здесь порядок важен, но компилятор может вычислить в любом порядке
cout << i++ << ++i; 
/**
((cout << i++) << ++i); 
operator<<( operator<<(cout, i++), ++i) как правило сначала вычислится ++i, а потом i++ (так в большинстве реализаций)
нестандартизовано
нежелательно употребляять выражения, вычисления которых зависят от порядка операндов.
*/
```
В процедурных языках для двуместных логических операций характерно ленивое вычисления:
```Pascal
i:=1;
while (i <= N) and (A[i] <> x) do
	i:= i + 1;
/** 
не удовлетворяет стандартам, компилятор может вычислять в любом порядке. корректно работает только когда х есть в массиве. Если i за пределами массива и компилятор вычисляет все, то будет выход за пределы массива
тогда нужно вынести второе условие
TurboPascal, C, C++.. требуют ленивые вычисления, все выражение не будет вычислено, если i за пределами массива:
while (i < N && a[i] != x) i++;
*/
```
```
A x = null;
if (x != null) {}
```
В JavaScript и Python можно использовать логические операции с не логическими типами. В Python false — 0, None, [], {}, () (пустые структуры), в JavaScript — 0, null, undefined, [].
```JavaScript
v1 && v2 // если v1 false, то v1. Если v1 true, то значение v2
v1 || v2 // если v1 true, то v1. Если v1 false, то значение v2
// верно для любого типа данных
```

#### Символьные типы

В Go, C нет символьного типа данных. В С 'a' — константа типа int, а в С++ — типа char. C: int getchar(). В какой-то степени char, wchar_t — символьные типы данных, но с арифметическими свойствами.
С++:
```C++
basic_string<T>
string s; // basic_string<char>
wstring ws; // basic_sring<wchar_t>
```

В Python, JavaScript, Go — нет char, но есть string (на уровне базового понятия языка).

```python
l=['a', 'b', 'c']
s = "".join(l)
```

Swift: пришел на замену Objective C. 

Счетчик ссылок (в Objective C так строилось взаимодействие между объектами):
```
if (_ref_count == 0) {
	delete this;
	return 0;
}
```
> Яблоки не люблю вообще, особенно грызенные.
