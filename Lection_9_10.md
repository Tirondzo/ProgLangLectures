### Лекция 9, 10 01.10.19

#### Связывание

Конструкция ЯП связывается с набором атрибутов (выбор из некоторого конечного множества)

* *Переменная и адрес*
* *Момент связывания*: квазистатическое связывание переменной с адресом (статическое смещение относительно указателя на фрейм). Еще может быть статическим и динамическим.
* *Время жизни связывания*. Для императивных: совпадает с временем жизни переменных. Не для всех языков это так: чем ниже уровень языка, тем это вернее (связывание переменных с адресом характерно для низкоуровневых ЯП).

```C# 
// в ЯП со сборщиком мусора может возникать дефрагментация памяти
byte[] ab = new byte[N]; // динамический массив, ссылка в С#, подверженная сборщику мусора и менеджеру памяти
unsafe { // помечается атрибутом unsafe
	fixed(byte *p = ab) // происхоит фиксация адреса в р
	{
		p++; // внутри фиксированного блока можно использовать malloc и т.д., и таким образом можно делать по сути "вставки" из С или С++, убираем сборку мусора.
	}
} 
```

* *Переменная и значение*. Связывание на уровне языка.
     * Императивные языки. Переменная отличается от константы временем жизни связывания. В какой момент происходит связывание константы? Ограничение накладывается на время жизни связывания, и it depends. К. Ричи был против констант в С++, так как не понятно, в какой момент вычислять константы. В С вычислялись на этапе препроцессирования или компиляции, а константы типа "const X a;"  — ? 
     
```C++
#define H (B - A)/N // неправильно
#define H (B - A)/(N) // верно, так как вместо N тоже может быть макрос 
	
const int N = 10;
int a[N]; // — код из С++, но не С.
```

> В С++ появились прототипы функций, потому что компилятор генерировал код, основываясь на том, передавать ли параметр по ссылке или по значению. В С прототип функции изначально был просто "type function()", компилятор даже не проверял параметры.

* --//--<br />
    * В функциональных языках остается связывание вызова фактических переменных функций и формальных.
     * И там и там связывание динамическое, в функциональных языках время жизни связывания совпадает с временем жизни переменной. Связывание происходит раз и на всегда, нет понятия состояния, переменная не меняет значение. Переменные ведут себя как константы в императивных ЯП.

> В С# конкретизация шаблонов происходит во время трансляции.

*В C#:*
```C#
const int N = 10; // const по умолчанию статические, связывание выполняется статически
int M = 10; // должно быть членом какого-то класса, если не статический объект, то инициализация происходит во время выполнения, так как объекты появляются на этом этапе
readonly int L = 10; // динамическая инициализация, время жизни связывания совпадает с временем жизни переменной
// инициализация статических объектов (эффективно) реализуется в отдельном статическом потоке, запускаемые системой времени выполнения
```
*В C++:*
```C++
const X a; // инициализация происходит в runtime
```

* *Переменная и тип данных*. 
> Интерпретатор языка С никому не нужен (хотя его можно написать)ы, так как он будет работать в десятки раз медленне, чем откомпилированный код.

Компилируемые языки: $$T_{comp} frac T_{inter} > 1$$
