### Лекции 17, 18

### Виды памяти
* Статическая
* Квазистатическая (привязка статическая относительно стека во фрейме), проблем не возникает, так как все современные архитектуры поддерживают стек, есть соответствующие регистры (EBP, ESP)
* Динамическая, тут возникают основные проблемы. 
	* Явное управление динамической памятью: 
		* C
		* C++
		* Rust
	* Неявное управление: 
		* Java
		* C#
		* JavaScript
		* Python
		* Swift
		* Go

Понятие **владение**: владелец памяти ответственен за ее освобождение
В С++: концепция единоличного владения -- auto_ptr (неудачная попытка)
Копирование противоречит концепции единоличного владения, с auto_ptr сложно отследить моменты копирования. unique_ptr решает проблему, так как отсутствуют оператор присваивания и конструктор копирования в обычном понимании.
```C++
<Объявление метода> = delete; // этого метода по сути нет, он отменен (чтобы, например, не генерировался дефолтный конструктор копироавания)
X(X && rval) {}
operator=(X&& rval) {}
```
У unique_ptr<T> есть операции \*, ->, T\* get() <=> единоличное владение
shared_ptr<T> -- \*, ->, T\* get() <=> совместной владение. Заводится счетчик ссылок. Методы этого класса могут отслеживать ссылки друг на друга.
```C++
struct Item {
	std::shared_ptr<Item> pItem;
	string name;
	...
};
int main() {
	auto Foo = make_shared<item>(); // внутри вызывается new, создается динамический блок, есть обычный указатель и много другой информации и методов
	std::shared_ptr<Item> Bar = make_shared<Item>(/*аргументы отсюда передаются в конструктор*/);
	// аналогично и с unique
	// Для них можно добавлять custom deleter
	Foo->pItem = Bar;
	// деструкторы: вызовется деструктор shared_ptr. Bar разрушится, потом разрушится Foo, и автоматически все будет освобождено.
}
```
custom deleter: например, для FILE* -- deleter, который делает fclose().

Главная проблема подсчета ссылок -- перекрестные ссылки (cross-reference)
```C++
struct Item {
	std::shared_ptr<Item> pItem;
	string name;
	...
};
int main() {
	auto Foo = make_shared<item>();
	std::shared_ptr<Item> Bar = make_shared<Item>();
	Foo->pItem = Bar;
	Bar->pItem = Foo;
	// ни один деструктор не вызовется, указатели разрушатся, а сам объект - нет, так как счетчик ссылок будет не нулевой. Поэтому было введено понятие слабых указателей
}
```
Слабые ссылки -- возникли в ЯП с динамической сборкой мусора. Слабая ссылка -- ссылка на объект, который не был разрушен, но на него уже никто не ссылается. Слабая ссылка может стать сильной (то есть станет действительной).
```C++
std::weak_ptr<T> wptr; // не владеет объектом и не может его разрушать
// нет операций * и ->
// есть методы:
bool expired(); // можно сказать, валидна ли ссылка. в многопоточном окружении может быть небезопасным
std::shared_ptr<T> lock(); // переводит weak в разряд сильных ссылок
if (auto t = wptr.lock()) {
	// здесь безопасно работать с t
	t->...
	// при необходимости объект будет разрушен
} else {
	
}
```
```C++
struct Item {
	std::weak_ptr<Item> pItem;
	string name;
	...
};
int main() {
	auto Foo = make_shared<item>();
	std::shared_ptr<Item> Bar = make_shared<Item>();
	Foo->pItem = Bar;
	Bar->pItem = Foo;
	// Ссылки становятся слабыми. Мы не владеем объектом, занчит, мы не можем к нему обращаться.Но решает проблему перекрестных ссылок. 
	// Также weak_ptr будет являться "наблюдателем"	
}
```
```C++
struct Item {
	std::unique_ptr<Item> pItem; // тут может быть сообщение об ошибке, так как для структур будет генерироваться конструктор копирования и оператор присваивания, нужно обеспечивать move-семантику
	// unique_ptr нельзя передавать по значению, так как нет конструктора копирования
	string name;
	...
};
```
```C++
// (const) X * const - тип this
enable_shared_from_this(this) // тогда должно быть:
class X : public enabled_shared_from_this {...};
```
### Структурный базис
* Массив
* Запись (структуры в С/С++). В дальнейшем перешли в классы
* Файлы. В дальнейшем ушли в стандартную библиотеку
* Множества. В дальнейшем ушли в стандартную библиотеку или стали таблицами

```Pascal
set of T; // отображение в числа от 0 до N-1
```
```Modula2 -?
BITSET
SET OF [0..N-1]
```
*Кортеж:* одновременное присваивание. Неизменяем (в питоне)
В С++ тоже появились кортежи:
```C++
std::tuple<int, char*> t;
std::get<i>(t);
```
*Массивы:* операция индексирования
A: D x ... x D (n раз)
[ ]: A, i -> ref D // возваращается ссылка
По факту динамическая операция
Массивы -- изменяемый объект.
Строки в большинстве ЯП нельзя рассматривать как массивы
Нет выравнивания
*Запись:* обращение к полю
R: D1 x ... x Dn
. : R, name -> ref Di
Время связывания статическое
Выравнивание -> можно делать масивы структур

Но в JavaScript все не совсем так. Массив -- напрерывная область памяти, да, но записей в JS нет, есть объекты:
```JavaScript
var o = {}
o.prop = 1 // свойство с именем prop отыскивается во время выполнения
// если такого свойства нет, то оно добавится. Объект - как хэш-таблица свойств
// аналогично с индексированием:
o["prop"] = 1 // эта запись аналогична предыдущей, кроме того, что индекс может быть произвольным значением, приведенным к строке
// индексирование и обращение к полю - вычисление хэш-функции
var i = o.prop // если свойства prop нет, то значение i  будет "undefined"
del o.prop // добавленное свойство можно удалить
```
#### Массивы
A: D x ... x D (n раз)
[ ]: A, i -> ref D // возваращается ссылка
В общем случае применимы и другие операции:
Length: A -> n
Если эта операция выполняется в runtime, то массивы динамические, связывание такой операции динамическое (C#, Java, JS, list  в Python). Проблема настоящего динамического массива
*C#:*
```C#
T[] t = new T[N]; // N - длина массива
t.Length;// N
// IList<T> List<T> могут динамически менять длину, но могут быть не эффективны по памяти
```
*Python:*
```Python
l = [1, 2, -28]
l.append("line")
# l[0] = 1
# l[4] = "line"
# l[5] - error
# l[-1] = "line", -1 is  len(l) - 1
```
*JavaScript:*
```JavaScript
var a = new Array()
a[i] = i // расширение массива, если элемента с таким индексом нет, то он появится
del a[i] // удаление элемента
```
Есть ЯП, в которых длина массива -- статическая функция:
*Pascal:*
```Pascal
type ARR = array[1..N] of integer;
function SumARR(var A:ARR) : integer;
```
Modula, Oberon -- понятие открытого массива
```
PROCEDURE SumARR( var A:ARRAY OF INTEGER):INTEGER; // неявно передается длина массива
// HIGH(A) - значение последнего индекса в открытом массиве
```
*C:*
```C
pipe(int fd[2]);// передается именно массив, а не указатель
```
*Go:*
```Go
var N int = 8;
arr int[N]; // нельзя
arr int[8]; // можно
len(arr); // статически заменяется на 8
```
Вырезка (срез, slice)
*Python:*
```Python
# вырезка применима к общему объекту, который дает итератор и возможность индексирования
l[i:j:step] # default step = 1, default j = len(l), default i = 0
l[:] # весь массив
l = [1, 2, 3]
l1 = l
l[0] = 0
l1[0] # станет 0
l1 = l[:] # полная копия
l = [1, [1,2], 3]
l1 = l[:] # "копия глубокая, да не очень"
l1[1][1] = -1 # ссылка на второй элемент, он изменится
print(l) # выведется [1, [1,-1], 3]
l1 = l[::-1] # последовательность в обратном порядке, step=-1
```
*Swift:*
```Swift
l[i..<j] // "окошко, через которое мы смотрим на массив"
let a = l[1:3]
// можно обращаться только к a[1], a[2], a[3]
```
*Go:*
```Go
// окошко, через которое мы глядим на отдельный массив, как будто это отдельный массив
arr int[4] = {1, 2, 3, 4};
// вырезка от элемента i до j - 1
// вырезка:
s int[];
s = arr[1:-1]; // все элементы, кроме первого и последнего, индексы 1 и 2
arr1 int[4] = {1, 2, 3, 4, 5};
s1 int[];
s = arr1[1:-1]; // индексы 1, 2, 3
// функция make
a := make(int[], 5, 10); // 5 - len 10 - capacity, тип а - вырезки из int, массив будет длины 10, в вырезку войдут только 5 элементов
```
