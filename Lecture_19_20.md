### Лекции 19, 20

* Многомерные массивы
* Записи и объединения
* Кортежи
* Таблицы (словари)

### Многомерные массивы

Есть типы-значения, а есть референциальные типы.
> Тип данных = Набор значений + Набор операций

Язык без референциальных типов -- 

Семантика размещения объектов в памяти:
* Референциальные типы --- значения в динамической памяти, доступны по ссылке
* Объекты типов-значений --- не все так однозначно: в зависимости от контекста объявления/появления соответствующего значения
	* Ассемблер: данные располагаются только внутри какого-то сегмента
	* Другие языки: возникает понятие области видимости --- 
		* Модуль. В С переменные, объявленные в модуле, помещаются в глобальный сегмент данных, данные загружаются в память, когда файл загружается в память (это происходит еще до точки входа в программу). В модульных языках по-другому. С точки зрения привязки к адресам --- статические переменные. В модульных яп данные появляются в оперативной памяти: модуль загружается в память (но загрузка может быть динамической, хотя все равно привязка будет считаться статической)
		* Блок. В С у таких переменных класс памяти --- стек. 
		* Класс. Значеня типов-значений расположены внутри объектов этого класса.
```C#
class X {
	T a = new T(); // ссылка
	T b;
	X(T bb) { b = bb; }
};
```
```
int a[2][10]; // расположение в памяти по строкам (по столбцам только в Fortran)
```

*Непрямоугольный массив:*
В яп типа С можно только моделировать.
```C
int main(int argc, char **argv) {}
int main(int argc, char *argv[]) {} // более наглядно, что argv - массив из указателей. здесь argv константный, в отличие от **argv, хотя они почти эквивалентны.
// **argv и *argv[] могут моделировать непрямоугольные массивы
```
Для типов-значений нужно знать длину массива, чтобы компилятор мог разместить в памяти. Если не требуется сразу, то это референциальный тип. Исключение --- динамические массивы в Ada.
```Java
// Java
class Point{...}
Point[] p = new Point[N];
```
```Ada
procedure P(N: integer) is
	var a: array(0..N-1) of integer;
	begin
	...
	end P;
```
Динамические массивы из Ada перешли в C в виде VLA (C 99).
```C
int n = atoi(argv[1]);
int a[n];

void *alloca(size_t n); // выделяет память на стеке
```
*Java:*
```Java
int[][] b = new int[N][];
for (int i = 0; i < N; i++) 
	b[i] = new int[i + 1];
// b[i][j]
int [,]a = new int[10, 5]; // Заметка от студента: НЕТ ТАКОГО СИНТАКСИСА В JAVA!
```
*C#:*
```C#
struct Point {
	int x;
	int y;
	public Point(int x, int y) { this.x = x; this.y = y; }
	int X {
		get {return x;}
		set {x = value;}
	}
}

Point []p = new Point(); // будет рассматриваться как массив объектов структур, семантика типа-значения (если бы Point был классом, то это был бы массив ссылок, и памяти затрачивалось бы больше)
// структуры нельзя наследовать. Есть класс struct, все структуры являются неявными наследниками этого класса
void foo() {
	Point p = new Point(1,2); // р будет расположен в стеке
}
class X{
	Point p = new Point(1,2); // p будет расположен внутри  объекта класса
}
void bar(object o) {} // в функцию можно передать все что угодно, если речь об ООП
bar(p);
```
### Записи и объединения
*Visual Basic: *
```Basic
type S is
	name as string * 20
	surname as string * 40
end type
```
Записи (record) появились в языке COBOL, они использовались для записи структур данных в файл.
S. : точка позволяет получить ссылку на поле (ref field) -- статическая операция, вычисление смщения относительно адреса начала записи.
Запись -- совокупность переменных.
```Java
Math.sin(x)
...
// в Java нет статических классов
static import Math.*
```
```C#
static class Path{...} // в С# есть статические классы
```
```C#
double Integrate(double A, double B, double EPS, double (*()(double)))
```
```Java
abstract class Integral {
	public double Integrate(double A, double B, double EPS) {..}
	public abstract double F(double);
}
new Integral {
	public double F(double x) {return sin(x);}
}().Integrate(0, PI, 1E-6); // new можно делать у анонимного абстрактного класса, у просто абстрактного нельзя
```
### Кортежи
В динамически типизированных яп понятия структур нет.
В Python есть понятие кортеж (размещаетяс в динамической памяти, имеет ссылочую семантику, но менятьего нельзя)
```python
l = (1, 2, "string")
#l[0], l[1], l[2]
a, b, s = l #значения кортежа будут распакованы в эти переменные
f((a, b, s)) #запаковали a, b, s в новый кортеж
l = (a, b, s) #значения запакованы в кортеж
f(l)
```
### Словарь
*Python:*
```python
d = {"a":1, "b":2, "s":"string"}
d["a"] # обычный синтаксис обращения к словарю
# ключом может быть только неизменяемый объект (hashable, immutable)
# можно динамически вычислять имя записи
# словарь как частный случай записи
# коллизии - значение хэш-функции для разных ключей одинаково. Разрешение коллизий
```
В JavaScript словарь будет объектом:
```JavaScript
d = {"a":1, "b":2, "s":"string"} // стандартный способ работы с объектами, так задается любой объект, объект по определению является словарем
d.a // чтение: если не найдено свойство, то переходим к прототипу и так далее
d.с = d.s // запись: если свойства нет, то оно появится
```
*C++:*
```C
std::unordered_map<>; // 
```
*PHP:*
```PHP
$a[] = 1  
$a[1] // операция доступа к элементу массива, если он есть
$a["1"] // массив работает как хэш-таблица. Любой массив одновременно является хэш-таблицей с внутренним разрешением коллизий
```
### Кортежи (продолжение)
*Go:* осталось понятие структуры (кортежи тоже есть в каком-то виде). Структуры по сути нужны были для того, чтобы функция могла вернуть несколько значений, в Go можно так:
```Go
val, _ = Fun(...)
//или
val, err = Fun(...)
```
*C++:*
```C++
std::tuple<int, int, std::string> p = mstd::make_tuple(1, 2, "string"/*const char* -> std::string*/);
std::get<0>(p); // p[0]
// C++14 - расширение стандарта для кортежей произвольных размеров (переменный список параметров в шаблоне)
```
### Объединение типов


