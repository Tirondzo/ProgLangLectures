

### Лекция 13, 14 15.10.19
#### Символьные типы данных и строки
. ? !
ASCII 7
* JS, Python, PHP, ... — динамически типизируемые языки (не содержат типа char, только строки)
* Статически типизируемые — как правило есть тип char, но в Go — тип rune (=uint32), нет отдельного символьного типа. Java: char => ushort. 

70—80-e: какие представления текста использовать?
* Однобайтовые кодировки символов (SBCS — single byte)
* Двухбайтовые кодировки (DBCS — double byte)
* MBCS

Система кодировки символов появилась в 19 веке (с появлением телеграфа), появились символы BackSpace (сдвиг каретки назад), Del (игнорировать послежний символ), CR (carriage return), LF (line feed), FF (form feed).

  Однобайтовая кодировка: первые 128 символов — англ (американский стандартный код, ASCII7, ANSI-7), остальное можно использовать 128-255 под другие символы (национальные кодировки, а их достаточно много => как разграничить?).
  Появилось разграничение на алфавиты восточной и западной Европы. Была разработана ISO-Latin1 для западной Европы, для остальных — ISO-Latin2, ISO-Latin3... . Японцам и китайцам пришлось упростить иероглифы и придумать свою кодировку (сначала двухбайтовую, потом многобайтовую). 
  Есть глобализованные приложения, а есть локализованные (все, что является текстом, должно отображаться в целочисленные идентификаторы, которые потом отображается в конкретные строки, загружаемые по их идентификаторам, строковые литералы, которые зависят от национального представления, в программе появляться не должны) => для подготовки локализации достаточно просто перевести текст. Но интерфейс должен адаптироваться к размерам ресурсов (например, размеру экрана). Глобализация — работа приложения везде, то есть нужно универсальное представление символов. Локализация требует перекомпиляции, но глобализация должна быть универсальной, требуется универсальное представление текстов =>
  **Появление UNICODE (1991)**
  CP1252
  CP1251
  CP866 — кодировка кириллицы в MSDOS
  UNICODE не стандарт кодировки, это стандарт алфавита.
  
  1. Стандартизуются алфавиты (наборы символов, Universal Character Set) — стандартизуются названия символов (например, small latin latter 'a').
  2.  Не стандартизуется представление (глиф). Например, в арабском: 23 буквы, у каждой до 4 написаний (для разных мест в слове).
  3. Стандартизованы коды (уникальный номер символа) — Code Point. Кодировка отличается от Code Point тем, что говорит, как именно представить код в компьютере.
UTF32 (то, как UCS переводится в кодировку 0—0х10FFFF).
Для символов `: можно либо выделить отдельные символы для букв с accents (é), либо сделать accent модифицирущим символом (если accent идет за буквой, то глиф будет объединением двух символов).

Наиболее используемые кодировки:

* UTF-8
* UTF-16 
* UTF-32

Старый UNICODE получил название BMP (Basic Multilingual Plane). Символы стали обозначаться U+AB — это символ из BMP. Всего плоскостей 16. U+81FAB. 1..F. Максимальный символ — 0x10FFFF. 
> Все эти эмотиконс.. Эмоджики...

*С:*
Все стандартные функции для работы со строками находятся в библиотеке <string.h>
```C
strlen(char *);
wcstrlen(wchar_t *);
strcat(x, y);
wcstrcat(wx, wy);
```
**BOM (byte order mark)**

0xFFFE

* В машинах с прямой адресацией: FF FE
* Little endian: FE FF

В сети прямой порядок, поэтому нужны функции htons(), htonl(), wtohs(), wtohl() (при необходимости переводят формат).
В файлах сначала указывается BOM (кодируется тремя байтами), поэтому пустые файлы не совсем пустые (хотя для UTF-8 BOM не имеет значения).
*
Java, C#:* char — 2 байта
> UTF-16 — наихудшая из всех возможных кодировок UNICODE

*JavaScript:*
line[0] — не всегда первый символ строки. Строку в символы можно превратить с помощью функции s.split("").

*Go:*
Строки — последовательность байтов (не последовательность символов или рун). Последовательность байтов кодирует последовательность из UTF-8.
```Go
s string = "line"
fmt.printf(s[0]) // выдаст код символа l
s1 string = " "
frm.printf(s1[0]) // выдаст 32 — код пробела
len(s) // число байтов в кодировке
```
Тип rune, модуль utf8:
```Go
DecodeRuneInString(s) // выдаст пару (r rune, s size)
for i := 0; i < len(s);  // ++i — нет такой операции
{
	// автоматическая декларация
	r, sz := DecodeRuneInString(s[i:]) // вырезка, строка, начинающаяся с i-го байта
	// может быть только 110, 11110, 1110, 0_... (10 - продолжение)
	i += sz
}

// или
for r, sz in s {
	do_something()
	// ?
}
```
Длина "café" — 4, "cafe\u301" — 5. Но отрисовывается 4 глифа.

Extended grapheme cluster — есть соответствие для символа é (U+E9) или с модифицирующим символом `: е + U+301.

*Swift:*
```Swift
s.Length("<emoji>") // == 1
let s = "café"
let s1 = "cafe\u301"
s.Length == s1.Length // решена проблема нормализации
// здесь операция длины — O(n)? <непонятно, может зависеть от компилятора>
s[0] // будет ошибка компиляции при обращении к s[0]
// строка считается строкой с прямым доступом, но только если обращаться со специальным типом данных - индексом
s[s.firstIndex] // индекс самого первого символа в строке
s.Index(of: "a", offset: 7)
s.Index(of: "a") // индекс первого вхождения символа а (подстроки)
c: character = "a"
s.Index(of: c, offset: 1) // индекс первого вхождения с + 1
s[s.Index(by: lastIndex, offest: -1)] // последний символ строки
// сохраняется соответствие между символами и тем, что будт выведено
```

*Objective-C:*
NSString - неизменяемая строка
String - изменяемая строка

**Интерполяция строк**
Впервые появилась в интерпретируемых ЯП
Внутрь строки вставляются некоторые значения, которые потом вычисляются и выводятся.

*PHP:*
```PHP
"hello, $i" // с $ начинается переменная, значение идентификатора i  вставится в строку
```

*Swift:*
```Swift
"\expression" // может быть любое выражение, переменная и тд
"cafe\u301"
```

*C#:*
```C#
"$i" // но это не точно
```

В С такого нет, так как интерполяция может быть только внутри строковых литералов и делает новый литерал в рантайме, следовательно, нужна динамическая реализация строк, которой нет в С (в С статическое распределение памяти для строк).

#### Перечислимый тип

Был в Обероне, но Н. Вирт выбросил его из языка, так как он не соответствовал концепции расширяемости языка.

```
TYPE T = (A, B, C, ...);
```

В Ada: пусть литералы перечисления совпадают:
```Ada
Red'TrafficColour
Red'RGBColours
TYPE charset1 =('A', 'B', 'C',...); // собственная кодировка соответствующего charset
```
90-е: перечислимые типы начинают выпадать из ЯП.

В Java вновь появились в 2005, но как разновидность классов:
```Java
enum Fruits { // класс специального вида
	Apple, // статические константы класса
	Orange,
	Pineapple,
	... 
}
```
```Java
enum Fruits { 
	private int price;
	Apple (10), 
	Orange(20),
	Pineapple(30),
	... 
	// может быть конструктор
	public Fruits(int price) {
		this.price = price;	
	} 
}
```
Перечисляемому типу необязательно быть расширяемым.
```Java
Fruits.Apple; // константа локализована в Fruits
```

*C++11:*
```C++
enum class Fruits {
	Apple,
	Orange,
	Pineapple,
	...
}
Fruits f = Fruits::Apple;
```

