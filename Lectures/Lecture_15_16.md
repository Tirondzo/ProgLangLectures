### Лекции 15, 16

#### Перечисления
*C#:*
```C#
enum Color {
	Red   = 0xFF0000,
	Green = 0x00FF00,
	Blue  = 0x0000FF
}
var c = Color.Red;
c++; // Now has value 0xFF0001.

enum Planet {
    Earth,
    Mars
}
var c = Planet.Earth;
c++; // Now has value Planet.Mars.
```
```C#
enum TrafficColor:byte {
	Red,
	Yellow,
	Green
}
var tc = TrafficColor.Red;
```
```C#
enum FileMode {
	Read      = 0x1,
	Write     = 0x2,
	ReadWrite = Read | Write
}
```
В С# есть механизм атрибутов (в частности это используется для задания опций компилятора, как pragma в С), можно задать, какие операции доступны для перечислимых типов:
```C#
[Flags] 
enum FileMode {
	Read      = 0x1,
	Write     = 0x2,
	ReadWrite = Read | Write
}
```
*C++11:*
```C++
// enum class
auto c = Color::Red;
```
Допускаются неявные преобразования из целого типа в перечислимый. Обратно -- необходимо явное приведение.
pragma не стандартизовано, зависит от компилятора.

#### Указатели и ссылки

В Pascal -- не отдельный тип данных (просто способ передачи параметров).
Ссылки как отдельный тип данных -- С++ и Algol-68. 
Algol-68 -- ортогональность языка, стерта разница между оператором и выражением, каждый оператор может иметь значение (например, оператор цикла имеет значение последнего выполненного оператора).
```Algol-68
ref int
ref T
ref ref int
```
В С ref перешли в *, чтобы не вводить отдельно новую концепцию (уже есть понятие машинного адреса, адресная арифметика). По факту вместо индексации массивов можно использовать адресную арифметику (так как массив в С -- непрерывный участок памяти, для индексации достаточно знать начало массива и размер типа данных).
В С++ & появилась как отдельный тип данных (так как не все можно выразить через понятие адреса, он слишком тесно связан с адресной арифметикой), например, невозможно обойтись без этого типа при перегрузке операторов.
```C++
class MyVector {
	int *_body;
	int _size;
public:
	explicit MyVector(int size) {...}
	MyVector(MyVector & v) {...} // во избежание рекурсивного вызова конструкторов значение передается по ссылке
	// необходимо перегрузить операцию присваивания, потому что если оставить дефолтную, то будут утечки памяти
	// проблема висячих ссылок, когда сслка считается определенной, но она уже недействительна
	int& operator[](int i) {return _body[i];}// lvalue and rvalue. без & -- только rvalue
	MyVector& operator=(const MyVector & v) {
		...
		return *this;
	}
};

MyVector v(30), v1(20);
v = v1; // проблема образования мусора (менеджер динамической памяти считает ее занятой, но на нее никто не ссылается), поэтому надо переобпределить операцию присваивания
MyVector v2(v); // v2 = v
v[j] = v1[i]; // нужно переопределить операцию []
```
> CLR: есть указатели, а есть gc^ (garbage collect)

*Oberon:*
```Oberon
RECORD D
	I:INTEGER   // закрытое поле
	J*:INTEGER  // открыто на чтение и запись
	J*-:INTEGER // открыто на чтение
```

T & a -- в С++ для ссылки доступна только операция иницаилизации (полный аналог имени).
```C++
T & a = * new T(); // a -- имя безымянной переменной T()
X & b(*new X());
T & c = a; // "Остапа занесло", у объекта два имени, создает путаницу, так писать не надо
// как удалить? нужно получить адрес:
delete &a; // разыменование, и это работает, так у Страуструпа!
f(int & i) {} // инициализация i происходит в момент вызова
f(k);
```

```C++
class Y {
	int &ri; // где инициализировать? в конструкторе:
public:
	Y(int rri) : ri(rri) {...} // "порядочные компиляторы будут тут ругаться", переменная передается по значению (локальная переменная), инициализируем переменную значением стека!
};

int* f() {
	int i;
	return & i; // висячая ссылка, будет ошибкой
}

int& f1()n {
	int i;
	return i; // висячая ссылка, будет ошибкой
}

int f2(int &k); // обязательное предварительное объявление функций (так как возник второй способ передачи параметров, по ссылке)
```

**В объектно-референциалных ЯП:**

Типы данных:
* типы-значения (Value Types)
* референциальные (обращение к ним возможно только через ссылку, именовать можно только ссылки, объекты являются анонимными):
	* классы
	* интерфейсы
	* массивы (как правило. Исключение: Go (но он по факту не объектно-референциальный))
```Java
X x = new X();
int[] a = new int[30];
int[] b = new int[20];
a = b; // теперь а и b ссылаются на одну область
```
JavaScript: строки immutable, они не копируются, копируются только ссылки.

Проблема поверхностного копирования: копирование только указателя или ссылки. Как обеспечить глубокое копирование (вдруг есть ссылка на узел в дереве, что тогда копировать? Только узел, поддерево, или вообще все дерево? Нет универсального способа, где-то нужно делать полную копию, а где-то частичную, это указывается автором структуры данных).

В С указатели играют роль и ссылок. С помощью адресной арифметики можно обрабатывать произвольный набор данных (struct, union, T[N]). Указатель в С по сути играет 2 роли, и, например, в объявлении функции мы не всегда можем понять, для чего именно будет служить указатель (либо как адрес -- strcpy(char *pa, char *pb), либо как передача значения -- swap(char *pa, char *pb)).

*Pascal:*
```Pascal
P.field;
// := - присваивание, ^ - разыменование
P.all; // обращение ко всей переменной
```

```Ada
T:INTEGER;
T'access;
PROCEDURE P is
	begin:
	...
	end P;
P'access;
type PT is access all T;
```

Проблема владения: если структура объявлена внутри объекта, то объект ответственен за освобождение структуры. Приобретение ресурса -- инициализация (RAII, resource acquisition is initialization). 
С++: свертка стека -- при выходе из фрейма для всех локальных переменных гарантируется вызов деструкторов в обратном порядке, кроме случая аварийного завершения (при использовании исключений деструкторы будут вызваны).

```C++
{
	// конструкция CWaitCursor w() означает прототип функции, поэтому надо (либо через new)
	CWaitCursor w; // захватывает курсор при инициализации, заменяет на waitcursor
	LongOp(); // как бы не закончилась эта операция, будет вызван деструктор для w
}
```

```C++
try {}
finally{} // здесь можно сделать освобождение памяти
```
*C#:*
```C#
// IDisposable
using (X p = new X()) {
	s1...sn // операторы
}
try {
	X p = new X();
	s1...sn // операторы
}
finally { // гарантируется, что выполнится
	((IDispose)p).Dispose; // освобождение неуправляемых ресурсов
}
```
*С++:*
```C++
p->field;
class SP {
	...
public:
	... 
	SP* operator->() {} // возвращает что-то, к чему применима -> (pointer)
};
```

<вроде как до 11 года>:
```C++
template<typename T>
class auto_ptr {
	...
public:
	explicit auto_ptr(T *p = nullptr);
	auto_ptr(const auto_ptr<T> &);
	auto_ptr& operator=(auto_ptr<T> &);
	T* get();
	T* operator->();
	T& operator*();
	void swap(auto_ptr<T> &p);
	~auto_ptr(); // delete
	// Можно прописывать свои deleter'ы
	...
	// в конструкторе и деструкторе не должно быть исключений (потому что деструкторы могут быть вызваны во время свертки стека)
};

template<typename T>
void swap(auto_ptr<T> &p1, auto_ptr<T> &p2);
...
auto_ptr<X> px(new X());
pr->field;
auto_ptr<X> make() {
	auto_ptr<X> p(new X());
	...
	return p; // будет работать конструктор копирования, который создаст новый auto_ptr (в нем нет const, по факту применяется операция swap)
}
```

```C++
void foo(auto_ptr<X> p) {
	...
	// конструктор копирования, а затем деструктор (?!)
}

auto_ptr<X> p(new X());
foo(p);
p->bar(); // BOOOOM

// исправление:
void foo(const auto_ptr<X> & p) {}
```
```C++
struct s {
	int id;
	auto_ptr<X> p; // операция присваивания будет автоматической
	s();
}
s s1;
s s2;
s2 = s1;
s1.p->field; // НЕЛЬЗЯ, p уже ни на что не ссылается
```
Проблема auto_ptr: вместо copy-семантики используется move-семантика.
Не пользуйтесь auto_ptr!!!
В 11 году: введение типа данных -- ссылки на rvalue (временные объекты).
```C++
T && x = T();
```
```C++
T & x = T(); // временный объект будет уничтожен на выходе из блока
```
```C++
X a = getX();
X && b = getX(); // создается временный объект, которому будет присвоена ссылка на временный объект. конструктор копирования для временного объекта
X d(getX()); 
X c;
c = getX(); // здесь работает операция присваивания. После этого временный объект уничтожался. Компилятор: если объект поддерживает move-семантику, то надо ее использовать.

// в классе Х:
X(X&&);
X& operator=(X&&); 
```
Аналог в С++14:
```C++
std::unique_ptr<X> p;
```
Проблема в использовании копирования. В C++11 это сделано приватным методом (копирование и присваивание с const X&). В С++14 введено ключевое слово delete.
```C++
X(const X&) = delete;
```
```C++
std::unique_ptr<X> p, p1;
p = std::move(p1); // сколько байтов кода будет сгенерировано? нисколько, по факту просто приведение типов.
```
