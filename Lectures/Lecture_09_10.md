### Лекция 9, 10 01.10.19

#### Связывание

Конструкция ЯП связывается с набором атрибутов (выбор из некоторого конечного множества)

* *Переменная и адрес*
* *Момент связывания*: квазистатическое связывание переменной с адресом (статическое смещение относительно указателя на фрейм). Еще может быть статическим и динамическим.
* *Время жизни связывания*. Для императивных: совпадает с временем жизни переменных. Не для всех языков это так: чем ниже уровень языка, тем это вернее (связывание переменных с адресом характерно для низкоуровневых ЯП).

```C# 
// в ЯП со сборщиком мусора может возникать дефрагментация памяти
byte[] ab = new byte[N]; // динамический массив, ссылка в С#, подверженная сборщику мусора и менеджеру памяти
unsafe // помечается атрибутом unsafe
{ 
	fixed(byte *p = ab) // происхоит фиксация адреса в р
	{
		p++; // внутри фиксированного блока можно использовать malloc и т.д., и таким образом можно делать по сути "вставки" из С или С++, убираем сборку мусора.
	}
} 
```

* *Переменная и значение*. Связывание на уровне языка.
     * Императивные языки. Переменная отличается от константы временем жизни связывания. В какой момент происходит связывание константы? Ограничение накладывается на время жизни связывания, и it depends. К. Ричи был против констант в С++, так как не понятно, в какой момент вычислять константы. В С вычислялись на этапе препроцессирования или компиляции, а константы типа "const X a;"  — ? 
     
```C++
#define H (B - A)/N // неправильно
#define H (B - A)/(N) // верно, так как вместо N тоже может быть макрос 
	
const int N = 10;
int a[N]; // — код из С++, но не С.
```

> В С++ появились прототипы функций, потому что компилятор генерировал код, основываясь на том, передавать ли параметр по ссылке или по значению. В С прототип функции изначально был просто "type function()", компилятор даже не проверял параметры.

* --//--<br />
    * В функциональных языках остается связывание вызова фактических переменных функций и формальных.
     * И там и там связывание динамическое, в функциональных языках время жизни связывания совпадает с временем жизни переменной. Связывание происходит раз и на всегда, нет понятия состояния, переменная не меняет значение. Переменные ведут себя как константы в императивных ЯП.

> В С# конкретизация шаблонов происходит во время трансляции.

*В C#:*
```C#
const int N = 10; // const по умолчанию статические, связывание выполняется статически
int M = 10; // должно быть членом какого-то класса, если не статический объект, то инициализация происходит во время выполнения, так как объекты появляются на этом этапе
readonly int L = 10; // динамическая инициализация, время жизни связывания совпадает с временем жизни переменной
// инициализация статических объектов (эффективно) реализуется в отдельном статическом потоке, запускаемые системой времени выполнения
```
*В C++:*
```C++
const X a; // инициализация происходит в runtime
```

* *Переменная и тип данных*. 
> Интерпретатор языка С никому не нужен (хотя его можно написать), так как он будет работать в десятки раз медленне, чем откомпилированный код.

Компилируемые языки: 
T_{comp} \frac T_{inter} \gg 1

#### Типа данных и операции

##### Базисные типы

* Скалярные типы
компилятор знает про эти типы. Не имеют внутренней структуры.
    
* Структурные типы

> Компилятор С "ничего не знает" о типах из стандартных библиотек
В других языках есть мимикрирующие под стандартную библиотеку

##### Скалярные базисные типы данных в ООЯП

* Числовые типы данных
     * Целочисленные
     * Вещественные
* Логический тип данных
     * В С не было
* Символьные типы данных
* Перечислимые типы данных
    * До 2005 не было в Java
    * Создатель С#: это красиво и удобно при использовании IDE
* Диапазоны
    * Впоследствии вылетел из ЯП. Раньше использовался для задания массивов:
```Pascal
array[0..N-1] of T; // диапазон, но задан неявно

```

```Modula-2
array.IndexType of T; // квадратные скобки  — свойство диапазона, а не массива, граница изменения индексов
Type T = [1..N];
Type T1 = CARDINAL[0..N];
```
* Указатели/ссылки
    * В некторых языках нет указателей, а ссылка не является отдельным типом (есть референциальный тип данных — классы, объекты, массивы, интерфейсы)
* Функциональные типы данных
* Строки (могут быть отнесены и к структурным).
    * В python и Go нет символьного типа данных
    * Как правило, неизменяемый объект
    * В С++ — тип из отдельной библиотеки
    
> Оберон  — ООЯП, в отличие от Modula-2, но при этом более простой и компактный. Компилятор на Обероне занимает около 4к строк. С выходом Оберон-2 компилятор стал занимать 400-500 строк.

```Оберон
ARRAY N OF T // диапазоны выпали из Оберона
ARRAY OF T // открытый массив, динамический
```

Нет типов currency и date, хотя они были бы очень полезны. Существуют в отдельных библиотеках.

Есть типы, а есть оболочки — типы-заглушки (например, int и Int32 в С#, int и Integer в Java). Сделано, чтобы базисные типы стали объектами: **boxing** (упаковка типов).

##### Числовые типы данных
1. Представление (диапазон).
    Есть понятие регистров общего назначения с определенной разрядностью. int — базисный тип, родной дла заданной архитектуры (4 или 8), могут быть типы меньшей размерности: byte, short; int. long, long long — если не хватает int. В C# есть byte — 1, short — 2, int — 4, long — 8 (оболочки — UInt8, Int16, Int32, Int64). Аналогично  в Java (фиксированные размеры, не как в С)
    
```C++
for (unsigned int i = 0; i < c.size(); i++) {} // size() — вернет size_t (unsigned int)
for (unsigned int i = c.size(); i >=0; i--) {} // будет зацикливание, смешение знаковых и беззнаковых операций
```

> Зачем нужны беззнаковые типы? 
> — Нет беззнакового типа — нет беззнаковых проблем.

Операции сдвига для знаковых и беззнаковых типов работает по-разному (в знаковых: если знак — 0, то в начале забьются нули, если 1, то 1. Арифметический — деление на степени двойки, —  и логический сдвиг — беззнаковый тип). По-хорошему, надо приводить к unsigned и делать сдвиг (логический сдвиг — операция >>>). С++ изначально: смешивать знаковые и беззнаковые типы нельзя. Были перекомпилированы утилиты UNIX, ни одна из них не прошла проверку на несмешивание знаковых и беззнаковых типов. В итоге было разрешено смешивать.
В C#: sbyte (знаковый byte, так как сам byte беззнаковый), ushort и т.д. Разрешены преобразования byte -> ushort -> uint -> ulong, byte -> short, ushort -> int и т.д.

В Обероне нет беззнаковых типов в целях минимизации.
